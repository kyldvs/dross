# Technical Specification: Monorepo Setup

## Design Philosophy

The simplest monorepo structure that enables productive Python and TypeScript development. Every file and directory must justify its existence through actual use, not hypothetical needs.

## Architecture Decision

**Two independent workspace roots** (`/python` and `/typescript`) instead of a unified root.

### Rationale

1. **Zero conflicts**: Python and TypeScript tooling never interfere with each other
2. **Tool defaults work**: Each ecosystem's tools find what they expect in standard locations
3. **Clear ownership**: Every file has an obvious owner (Python tooling or TypeScript tooling)
4. **Independent evolution**: Update Python tooling without touching TypeScript and vice versa
5. **Simpler mental model**: Developers work in one workspace at a time

### Trade-offs

**Chosen**: Separate workspace roots
- **Gain**: Tool compatibility, zero configuration conflicts, clear boundaries
- **Cost**: Cannot share dependencies across ecosystems (acceptable - this should be rare)
- **Cost**: Must run commands from two different directories (acceptable - most work happens in one ecosystem)

**Rejected**: Single root with `/src`, `/packages`, or similar
- **Cost**: Constant tool configuration overrides
- **Cost**: Ambiguous file ownership
- **Cost**: Risk of naming conflicts
- **Gain**: Single command location (not worth the complexity)

## Directory Structure

```
/
├── python/
│   ├── pyproject.toml              # Workspace definition only
│   ├── uv.lock                     # Generated by uv sync
│   └── packages/
│       └── example/
│           ├── pyproject.toml      # Package metadata
│           └── src/
│               └── example/
│                   └── __init__.py
│
├── typescript/
│   ├── pnpm-workspace.yaml         # Workspace definition + catalog
│   ├── package.json                # Private root, shared dev deps
│   ├── pnpm-lock.yaml              # Generated by pnpm install
│   ├── packages/
│   │   └── example/
│   │       ├── package.json
│   │       └── src/
│   │           └── index.ts
│   └── apps/
│       └── example/
│           ├── package.json
│           └── src/
│               └── index.ts
│
├── .gitignore
└── README.md
```

### Why This Structure

- **`/python` and `/typescript`**: Workspace roots, contain all tooling config
- **`/python/packages`**: Standard uv workspace location
- **`/typescript/packages`**: Shared libraries
- **`/typescript/apps`**: Standalone applications (servers, CLIs, websites)
- **`/src` inside each package**: Standard location, tools auto-detect
- **Root `.gitignore`**: Single source of truth for ignored files
- **Root `README.md`**: Project overview and workspace navigation

## Python Workspace Configuration

### `/python/pyproject.toml`

```toml
[tool.uv.workspace]
members = ["packages/*"]
```

**That's it.** This file:
- Defines workspace members using glob pattern
- Has NO project metadata (it's not a package)
- Relies entirely on uv defaults

### Package Configuration: `/python/packages/example/pyproject.toml`

```toml
[project]
name = "example"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

**Additions when needed:**
```toml
[project]
dependencies = [
    "requests>=2.31.0",
]

[tool.uv.sources]
other-package = { workspace = true }
```

### Internal Dependencies

Use `{ workspace = true }` in `[tool.uv.sources]`:

```toml
# In package A that depends on package B
[project]
dependencies = ["package-b"]

[tool.uv.sources]
package-b = { workspace = true }
```

uv resolves this to the local workspace package, not PyPI.

### Optional Configuration Files

**Only add when you need to override defaults:**

- **`ruff.toml`**: Per-package if you need package-specific rules
- **`ty.toml`**: Per-package if ty can't auto-detect layout (rare)

Start without these. Add only when proven necessary.

## TypeScript Workspace Configuration

### `/typescript/pnpm-workspace.yaml`

```yaml
packages:
  - 'packages/*'
  - 'apps/*'

catalog:
  react: ^18.3.0
  react-dom: ^18.3.0
  typescript: ^5.3.0
  '@biomejs/biome': ^1.9.4
```

**Start with minimal catalog.** Add versions as you use them in packages.

### `/typescript/package.json`

```json
{
  "name": "typescript-workspace",
  "private": true,
  "scripts": {
    "dev": "pnpm --recursive run dev",
    "build": "pnpm --recursive run build",
    "lint": "pnpm --recursive run lint",
    "format": "pnpm --recursive run format"
  },
  "devDependencies": {
    "@biomejs/biome": "catalog:",
    "typescript": "catalog:"
  }
}
```

### Package Configuration: `/typescript/packages/example/package.json`

```json
{
  "name": "@workspace/example",
  "version": "0.1.0",
  "type": "module",
  "main": "./src/index.ts",
  "scripts": {
    "lint": "biome lint .",
    "format": "biome format ."
  },
  "dependencies": {}
}
```

### App Configuration: `/typescript/apps/example/package.json`

Same structure as packages. Apps typically:
- Include a bundler (Vite, Next.js, etc.)
- Have more dependencies
- Are never imported by other packages

### Internal Dependencies

**Between TypeScript packages:**
```json
{
  "dependencies": {
    "@workspace/other": "workspace:*"
  }
}
```

**Using catalog versions:**
```json
{
  "dependencies": {
    "react": "catalog:",
    "react-dom": "catalog:"
  }
}
```

pnpm resolves `workspace:*` to local packages and `catalog:` to versions defined in `pnpm-workspace.yaml`.

### Optional Configuration Files

**Only add when needed:**

- **`biome.json`**: At `/typescript/biome.json` if you need workspace-wide overrides
- **`tsconfig.base.json`**: At `/typescript/tsconfig.base.json` if multiple packages share TypeScript config
- **`tsconfig.json`**: Per-package only if using tsc or tools that require it

Many tools (Vite, Next.js, Bun) don't need explicit tsconfig.json. Start without it.

## Dependency Management

### Python

- **Lockfile**: Single `/python/uv.lock` for entire workspace
- **Install**: `uv sync` from `/python`
- **Add dependency**: Edit `pyproject.toml`, run `uv sync`
- **Upgrade**: `uv lock --upgrade`

### TypeScript

- **Lockfile**: Single `/typescript/pnpm-lock.yaml` for entire workspace
- **Install**: `pnpm install` from `/typescript`
- **Add dependency**: `pnpm add <pkg>` from package directory, or edit `package.json` then `pnpm install`
- **Upgrade**: `pnpm update`

## Common Operations

### Creating New Python Package

```bash
cd /python/packages
mkdir my-package
cd my-package
mkdir -p src/my_package
touch src/my_package/__init__.py
cat > pyproject.toml << 'EOF'
[project]
name = "my-package"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
EOF
cd /python
uv sync
```

### Creating New TypeScript Package

```bash
cd /typescript/packages
mkdir my-package
cd my-package
mkdir src
touch src/index.ts
cat > package.json << 'EOF'
{
  "name": "@workspace/my-package",
  "version": "0.1.0",
  "type": "module",
  "main": "./src/index.ts",
  "scripts": {
    "lint": "biome lint .",
    "format": "biome format ."
  },
  "dependencies": {}
}
EOF
cd /typescript
pnpm install
```

### Adding Internal Dependency

**Python:**
Edit dependent package's `pyproject.toml`:
```toml
[project]
dependencies = ["other-package"]

[tool.uv.sources]
other-package = { workspace = true }
```

**TypeScript:**
Edit dependent package's `package.json`:
```json
{
  "dependencies": {
    "@workspace/other-package": "workspace:*"
  }
}
```

## Validation Strategy

Each component can be validated independently:

1. **Directory structure**: `tree` command shows expected layout
2. **Python workspace**: `uv sync` succeeds without errors
3. **TypeScript workspace**: `pnpm install` succeeds without errors
4. **Python package**: `uv run python -c "import example"` works
5. **TypeScript package**: `node` can resolve the package
6. **Workspace dependencies**: Importing between packages works
7. **Linting/formatting**: Commands run without errors

## What We're NOT Configuring

The following are explicitly out of scope and should NOT be added unless proven necessary:

- Test frameworks (Jest, pytest, vitest)
- Build tools (beyond package needs)
- CI/CD pipelines
- Git hooks
- IDE settings
- Docker configuration
- Documentation generators
- Version management tools
- Environment variable handling

## Design Review

### Does this solve the actual problem?

Yes. Requirements are:
1. Create Python packages ✓
2. Create TypeScript packages/apps ✓
3. Cross-package dependencies ✓
4. Consistent dependency versions ✓
5. Lint/format/type-check ✓
6. Zero configuration for common use cases ✓
7. Clear separation ✓

### Are we using the simplest possible approach?

Yes. We're using:
- Standard workspace features (uv workspaces, pnpm workspaces)
- Tool defaults wherever possible
- Minimal configuration files
- No custom scripts or tooling
- No abstraction layers

### Can each step be completed independently?

Yes. Implementation plan has clear, sequential steps that build incrementally.

### Have we avoided unnecessary abstractions?

Yes. No custom scripts, no wrappers, no shared configuration frameworks. Just the workspace features that come with uv and pnpm.

## Conclusion

This design provides a minimal, working monorepo foundation. Every file and directory serves a concrete purpose. All tooling uses standard, well-supported features. Adding complexity later is possible; starting with it is not necessary.
